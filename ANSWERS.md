Questions:
Define Software Engineering:
<!--
Software engineering is the systematic application of engineering principles, methods, and tools to the development and maintenance of high-quality software systems.
-->

What is software engineering, and how does it differ from traditional programming?
Software Development Life Cycle (SDLC):
 <!-- 
    Software Engineering is a structured approach to software development that involves planning, design, coding, testing, and maintenance to create high-quality, maintainable, and scalable systems. It emphasizes user needs, sustainability, and team collaboration. On the other hand, traditional Programming focuses mainly on writing code to solve specific problems without considering the entire software lifecycle. It involves simpler processes, minimal documentation, and is often done by individuals or small teams.
-->

Explain the various phases of the Software Development Life Cycle. Provide a brief description of each phase:
<!--
    1.Requirements: This phase involves gathering and documenting user needs and system requirements.
    2.Design: This is where we create high-level and detailed designs of the software architecture and user interface.
    3.Implementation: This where we write code and build the software according to the design specifications.
    4.Testing: This phase involves conducting various tests to ensure the software meets quality standards and functional requirements.
    5.Deployment: The product is then released to the public at this stage.
    6.Maintenance: This phase involves cotinuouse maintenance by providing ongoing support, updates, and enhancements after deployment.
-->

Agile vs. Waterfall Models:
Compare and contrast the Agile and Waterfall models of software development. What are the key differences, and in what scenarios might each be preferred?
<!--
    1. The Agile model  is incremental and higly iterative to changes. It involves continuous testing throughout the development process which is divided into small manageable units called sprint meetings to plan and review the project incrementally till its completion. Agile aims to create a dynamic, flexible and efficient development environment that can adapt to change and deliver high-quality products that meet customer needs. 
    AGILE wll be preferred in cases of building projects like E-Commerce and social media applications with functions like "Register", "Login", "Post", "Message", "Purchase" or cases of building a car, we will have to test fir functions like, "Speed", "Strength", "Durability" etc. Each of these functions will have to be tested during the development phase to check that the functions are working properly before release or go back to work on them again, this model also gives the opportunity to acquire creative ideas through client  feedback.

    2. On the other hand, Waterfall models are straightforawrd, sequential and less adaptable to changes because once one phase is complete it is difficult to change. It is a traditional approach that works best for projects with clear, unchanging requirements. While it provides structure and predictability, its inflexibility and late testing stages can pose challenges in dynamic environments where requirements may evolve. 
    WATERFALL might be ideal for projects with less functionalities, straightforward objectives and predefined expectations like building a portfolio website for a data analyst etc where the outcome is foreseen.
-->


Requirements Engineering:
What is requirements engineering? Describe the process and its importance in the software development lifecycle.
<!--
    Requirements Engineering is a fundamental aspect of software development. It defines project needs, aligns stakeholders, and supports planning, quality assurance, and change management. Effective requeirements enginnering enhances project success by ensuring the final product meets user needs, is on time, and within budget, while also maintaining high quality and managing risks effectively.
 
    It's processess include;
        - Gather requirements from stakeholders and other sources by conducting reviews and brainstorming sessions using case diagrams, user stories etc.
        - Refine and clarify the gathered requirements, identify any conflicts by prioritizing requirements, carrying feasibitlty studies and performing risk analysis.
        - Document the requirements in clear and detailed manner by creating a requirement specification i.e. the functional and non-functional requirements.
        - Ensure that the requirements accurately reflect the needs and desired outcomes of the project by reviewing requirements with the stakeholders, conducting wlakthroughs and inspections.
        - Manage changes to the requirements throughout the software development lifecycle byt tracking the requirement changes and progress, maintaining traceability and managing versions of the projects.
-->

Software Design Principles:
Explain the concept of modularity in software design. How does it improve maintainability and scalability of software systems?
<!--
    Modularity is a key concept in software design that emphasizes separating concerns, encapsulating components, and reducing dependencies. By breaking a software system into smaller, independent units, modularity improves maintainability by isolating changes, making the system easier to understand, and promoting reusability. It also enhances scalability by supporting parallel development, allowing for incremental scaling, and ensuring efficient load distribution. Ultimately, modularity results in more robust, flexible, and manageable software systems.

-->

Testing in Software Engineering:
Describe the different levels of software testing (unit testing, integration testing, system testing, acceptance testing). Why is testing crucial in software development?
<!--
Levels of Software Testing

1. Unit Testing:
   Unit Testing tests the individual components or units of code, such as functions or methods, to ensure they work as intended.
   This focuses on verifying the functionality of specific sections of code in isolation.
   The importance of this test is to catch bugs early in the development cycle, ensures each part works correctly before integration.

2. Integration Testing:
   Intergration testing tests the interaction between integrated units or components to detect interface defects.
   This test focuses on ensuring that combined parts of the application work together as expected.
   The importance of integration testing is to idintify issues in the interaction between modules, ensuring components work together correctly.

3. System Testing:
   This testing tests the complete and fully integrated software product to evaluate the system's compliance with its specified requirements.
   The importance of this test is to ensure that the system meets the functional and non-functional requirements and behaves as expected in a complete environment.

4. Acceptance Testing:
   This testing is conducted to determine if the software is ready for release, and it often involves end-users or clients. This focuses on Validating the system against business requirements and ensuring it meets the acceptance criteria.
   The importance of this level is to Confirm the software is ready for deployment, meets user expectations, and fulfills business needs.

Importance of Testing in Software Development

Testing is crucial for delivering reliable, functional, and high-quality software, contributing to overall success and user satisfaction.
-->

Version Control Systems:
What are version control systems, and why are they important in software development? Give examples of popular version control systems and their features.
<!--
    Version control systems are tools that help manage changes to source code over time. They keep track of every modification to the code in a special kind of database. If a mistake is made, developers can turn back the clock and compare earlier versions of the code to help fix the mistake while minimizing disruption to all team members.
    Version Control Systems are crucial in software development for collaboration, history tracking, branching and merging, backup and recovery, and maintaining code integrity.
-->

Software Project Management:
Discuss the role of a software project manager. What are some key responsibilities and challenges faced in managing software projects?
<!--
    A software project manager is responsible for planning, executing, and overseeing software development projects. They ensure that the project is completed on time, within budget, and meets the required quality standards.

    - Project Managers are responsible for planning, team management, risk management, stakeholder engagement, quality assurance, budget control, timeline management, and documentation. 

    The challenges Project Managers face include managing scope creep, resource allocation, risk, stakeholder expectations, technical issues, time management, quality control, and communication.
-->

Software Maintenance:
Define software maintenance and explain the different types of maintenance activities. Why is maintenance an essential part of the software lifecycle?
<!--
    Software Maintenance refers to the process of 
    modifying and updating applications after deployment to correct faults, improve performance, and adapt to changes, ensuring the software remains useful and relevant.

    Types of Maintenance Activities includes;

    Corrective Maintenance:
    - This involves fixing bugs and errors discovered in the software after it has been released by debugging, error correction.

    Adaptive Maintenance:
    This involves modifying the software to keep it compatible with changing environments, such as new operating systems, hardware, or software dependencies by updating libraries, adjusting to new platforms, and adapting to new standards.

    Perfective Maintenance:
    This involves enhancing and improving the software to increase performance, maintainability, or other attributes like code optimization and improving user interfaces or adding new features.

    Preventive Maintenance:
    This involves making changes to prevent future problems and improve the software's robustness
    using code refactoring, updating documentation, and restructuring code to prevent potential issues.

    Regular maintenance is essential for prolonging the software’s useful life, enhancing user satisfaction, maintaining security, and ensuring compliance, thereby providing ongoing value to users and stakeholders.
-->

Ethical Considerations in Software Engineering:
What are some ethical issues that software engineers might face? How can software engineers ensure they adhere to ethical standards in their work?
<!--
    Software engineers face a range of ethical issues, including privacy, security, intellectual property, quality, transparency, bias, and professional responsibility. Adhering to ethical standards involves ongoing education, following established codes of ethics, incorporating privacy and security best practices, respecting intellectual property, ensuring comprehensive testing, maintaining transparency, mitigating bias, and upholding professional accountability. These measures help ensure ethical conduct and the development of trustworthy software.
-->